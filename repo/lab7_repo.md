进程（线程）切换的一些背景知识：
1. xv6里的用户进程调度：进程1从用户态进入内核态（用户寄存器保存在trapframe里）->将内核线程寄存器存在context里,并切换到scheduler的context，zai scheduler找到下一个runnable的进程->切换到下一个进程的内核线程context,继续内核线程运行->从此线程的内核态恢复用户态（userret从trapframe中回复寄存器）
2. RISC-V中有32个寄存器，但是swtch函数中只保存并恢复了14个callee-saved寄存器,其余的caller-saved寄存器在进入swtch的时候被存储了，等从swtch出去的时候会自动恢复。（切换内核态保存所有寄存器到trapframe是为了安全）
3. Linux是支持一个进程包含多个线程， 比较简单的解释就是，几乎可以认为Linux中的每个线程都是一个完整的进程。Linux中，我们平常说一个进程中的多个线程，本质上是共享同一块内存的多个独立进程。所以Linux中一个进程的多个线程仍然是通过一个内存地址空间执行代码。如果你在一个进程创建了2个线程，那基本上是2个进程共享一个地址空间。之后，调度就与XV6是一致的，也就是针对每个进程进行调度。
4. 每次swtch回到线程继续运行的时候，都是先回到sched函数，但是第一次swtch切换后回到的是forkret，这是因为context在创建的时候把ra设置成了forkret的地址，forkret执行trapframe里，里面有父进程的epc（第一个进程设为0）

个人理解：
1. xv6一个进程只有一个用户线程，这个lab是要求在一个进程中实现多个用户线程，思路我们其实可以参考xv6的进程切换
2. 在一般linux等os当中，user stack处于高地址向下增长，heap低地址向上增长，查看exec的代码发现，在xv6当中，stack设置在了低地址向下增长，位于代码段之上两个page，第一个page是guard,第二个page是stack，stack不能超过一个page的大小，在我们的thread结构体当中，一个stack是8192个字节，也就是两个page，可以在初始化thread的时候把存储sp的地址设置成栈顶
3. 我们在thread结构体当中定义一个context来保存寄存器，在schedule当中swtch一下就可以
4. 第二个任务的理解：这个任务主要测试的是多线程共享内存加锁，随机初始化一些key，每个线程负责一部分key扔到5个桶里面，每个桶维护一个链表，记录桶里的key，假如不加任何锁，那么链表insert的时候很可能冲突，所以我们给每个桶加一个锁
5. semaphore和mutex的区别：互斥量用于线程的互斥，信号线用于线程的同步。互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。 简单理解：信号量wait可以相当于等待信号量>0 并给-1，signal就是给信号量+1，为了不同时修改信号量，还需要一个mutex来保护信号量，实际上应该不是+1-1操作的，感觉更像是把本进程压入一个等待的队列，然后signal释放一个进程，broadcast释放所有的